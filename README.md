# Cafeteria-Analysis

Data Structures Project 3

PROJECT 3 ANALYSIS
	The Cafeteria simulation takes four header files (cafeteria.h, group.h, student.h, and tray.h) to complete the processes involved in the implementation, cafeteria.cpp. The simulation creates a “cafeteria” and two stacks of trays filled with 3 colors of trays – 20 trays for each color. Students who are added into the cafeteria each have a color. They have to look through the stacks of trays to find a tray that is the same color as theirs. If they find one, they take it and are pushed into the corresponding group color. If not, they have to keep looking through the stack while pushing trays from the current stack to the other stack. If they still haven’t found one, then they check the other stack and repeat the process. If no tray was found, then the student picks the top tray of the first stack. Each student already knows what they want for their entrée, dessert, and how many ounces of salad they want.
  
	The first implementation, student.cpp, creates a student with a constructor that will assign them a name, color, entrée, dessert, the ounces of salad, and the total price of their food choices. The helper function, genPrice(), calculates the price for the student in the constructor. This information is used to calculate a group’s total price and the inclusion of a student into the group based on his/her color using getColor() in the pickTray() function in cafeteria.cpp. In this function, we simulate the scenario where the student picks his tray. In order to this, we create a count variable and assign it the sum of both generated stacks’ sizes in order to later check if one stack is full and the other is empty. Next, we set the seed with srand(seed) and initialize a variable called random_tray to a random number (either 1 or 2). Then we create a while loop making it continue until the student queue is empty (students have been popped from queue). We then create a switch statement for random_tray. From here, we pick either stack ts1 or ts2 depending on what number (1 or 2) was generated. Next, we create a temporary variable (temp_tray1) in order to hold the top tray of ts1 so that we could use getColor() to create another while loop comparing it with the current student (student.front().getColor()). In this while loop, we create another temporary Tray variable that will hold the top of ts1 so that we could pop the tray from the stack and insert it into the other stack (ts2) and then assign temp_tray1 to the new top, this way we could keep cycling through the stack while finding the right tray. If no tray is found, the while loop will break. If temp_tray1 is the same color as the student’s color, the student is added into each group using add.Student() in order to find the right group since each student’s color is compared to the group’s color before being included into a group in add.Student() and then we pop the student out of the student queue and the tray is popped from the current stack. If no tray is found, we loop through the other stack and loop through the same way, if no tray is ultimately found, the student chooses the first tray of the first stack and he/she is popped from the queue along with the tray. We repeat this process for case 2 of the switch statement. After we have placed all students into a group we then add these groups into the groups vector in order to print them out with the implementation of operator<< in group.cpp. The operator prints out the group by cycling through the students one by one while printing out their price at the same time using the same method to cycle through trays, except with a stack<student> temporary variable.
